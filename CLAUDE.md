# Quick Rules (non-negotiable lang 'to)

- never skip the research phase using context7, websearch, and reading files. immediate fail if you do
- never add complexity. keep it simple or we rewrite everything  
- never just accept requirements blindly. question everything with "is this really needed?"
- never create files that aren't needed (especially *.md files unless explicitly asked)
- always use sequential thinking MCP server, every single response needs this
- always warn about potential issues with "WARNING: ..." format
- always suggest the simpler approach when you see complexity creeping in

---

# Core System Instructions

## Auto-Commit Protocol (trigger this after every implementation task completion)

- when staging: just do git add . + git commit
- format should be: type(scope): description
- things to avoid:
  - no Claude Code references in commits
  - no emojis in commit messages
  - no "Generated by" messages
  - no Co-Authored-By tags
- example ng good commit: "fix(auth): resolve token validation issue"

## Development Restrictions

- never run pnpm dev, localhost, or any dev server. user controls this already
- just focus on the code, not running it

---

# Coding Principles (pero these are laws ha)

## The Non-Negotiables

- DRY (Don't Repeat Yourself) - code duplication means failure
- YAGNI (You Ain't Gonna Need It) - speculation gets rejected
- KISS (Keep It Simple, Stupid) - complexity means rewrite
- Minimalism - bloat means delete
- Law of Demeter - coupling means refactor  
- SoC (Separation of Concerns) - mixed concerns means split
- Filipino Wisdom: "Wag mong isama kung hindi mo kailangan" - apply to every line

## Optimization Rules

- check first: is the code even working correctly?
- if no: fix correctness first before anything else
- if yes: measure before you optimize anything
- default stance: no premature optimization, period

---

# Database Access (AWS MCP)

- use for information gathering only, read-only lang
- never integrate into repository or add as dependency
- always keep isolated from actual codebase

---

# Development Philosophy

## Core Focus: super simplify everything, walang complex

- avoid test files, manual testing lang tayo
- reject mock data, use real data always
- reject fallbacks, handle errors properly instead
- deep understanding means read the code first before anything
- clarity beats cleverness every single time
- minimal dependencies because each one is future technical debt

---

# Working with Subagents

## CRITICAL: Automatic Subagent Dependency (PROACTIVE MODE)

**ALWAYS AUTO-TRIGGER SUBAGENTS** - Never wait for permission, just launch them automatically
**NO ASKING REQUIRED** - User shouldn't need to say "use agent X" - you already know from context
**PARALLEL EXECUTION ALWAYS** - Run multiple agents simultaneously, the more the better
**PROACTIVE DEPLOYMENT** - See task → Match agents → Launch immediately → Report results
**DEFAULT BEHAVIOR** - Using subagents is the DEFAULT, not using them needs justification

### Automatic Trigger Rules

1. **Read ALL agent descriptions** when starting any task
2. **Match task keywords** to agent capabilities
3. **Launch ALL relevant agents** in parallel (not sequential)
4. **Give specific instructions** to each agent
5. **Combine insights** from multiple agents

### Automatic Trigger Examples (NO PERMISSION NEEDED)

**User says ANYTHING about code?** → Launch agents immediately:
```
User: "Implement user authentication"
YOU IMMEDIATELY LAUNCH (parallel, no asking):
- solution-archeologist: "Find existing auth implementations"
- pattern-replicator: "Match our code style for auth"  
- security-fortune-teller: "Check for future auth vulnerabilities"
- mistake-prophet: "Check our auth bug history"
- requirement-to-code: "Generate complete auth implementation"
```

```
User: "My app is slow"
YOU IMMEDIATELY LAUNCH (parallel, no asking):
- performance-optimization-analyzer: "Find all bottlenecks"
- code-x-ray-vision: "Visualize performance heatmap"
- code-time-traveler: "Show performance degradation timeline"
- auto-debugger-fixer: "Fix performance issues automatically"
```

```
User: "Add a dropdown menu"
YOU IMMEDIATELY LAUNCH (parallel, no asking):
- instant-feature-generator: "Check how Stripe/GitHub do dropdowns"
- solution-archeologist: "Find dropdown implementations"
- pattern-replicator: "Match existing UI patterns"
- ui-preview-generator: "Create interactive mockup"
```

**THE RULE**: User mentions task → You launch 3-7 relevant agents → No permission needed

## Key Capabilities

- **Multiple Perspectives**: Get opinions from multiple subagents on the same topic for comparison
- **Practical Implementation**: Ask the UI subagent to create actual HTML mockups based on their principles  
- **Iterative Refinement**: Each call is independent, pero pwede natin i-chain yung insights from one call to inform the next prompt
- **Expert Consultation Model**: It's like having multiple expert consultants na pwede mo kausapin one at a time, as many times as you need

## Usage Patterns

- **Comparative Analysis**: Call different subagents for varied expert opinions on the same problem
- **Deep Dives**: Start broad with general questions, then narrow down with specific follow-ups
- **Task Chaining**: Use output from one subagent to inform the prompt for the next
- **Practical Output**: Request actual code, mockups, or implementations based on their recommendations
- **Parallel Intelligence**: Launch 3-5 agents simultaneously for comprehensive analysis